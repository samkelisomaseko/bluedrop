<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>BlueDrop - Effortless File Transfers</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Exo+2:wght@400;700&family=Russo+One&family=Bebas+Neue&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
        integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewSTCcpyAfQKwiOp/oyuP3m18RReF9SvNKjC4JEjz+iCz2P+pIiuw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"
        integrity="sha512-D/0EOqpxJLQzA6NJgGBBgYkDgcOKQRrZl+JlhND78UiHrHIQshdJyi0Qs5OZ/4+Xh6XbG/c3BnXx7F/B0xS++g=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.1/dist/jsQR.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js"></script>


    <style>
        /* iOS 18.2 / iPhone 16 Pro Max Futuristic Fonts */
        @font-face {
            font-family: 'SF Pro Display';
            src: url('https://fonts.cdnfonts.com/s/93781/SF-Pro-Display-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        /* Font Stack */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'SF Pro Display', 'Orbitron', 'Exo 2', 'Russo One', 'Bebas Neue', -apple-system,
                BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
        }

        :root {
            --primary-bg: linear-gradient(135deg, #0d1117, #1e2a47);
            --primary-accent: linear-gradient(145deg, #3a69d4, #1f4bd6);
            --secondary-accent: linear-gradient(145deg, #7c6bff, #5a4ef9);
            --card-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.8);
            --border-color: rgba(255, 255, 255, 0.15);
            --shadow-color: rgba(0, 0, 0, 0.2);
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107;
        }

        .dark {
            --primary-bg: linear-gradient(135deg, #0d1117, #1e2a47);
            --card-bg: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.8);
            --border-color: rgba(255, 255, 255, 0.15);
        }

        .light {
            --primary-bg: linear-gradient(135deg, #e0e5ec, #f5f7fa);
            --card-bg: rgba(0, 0, 0, 0.05);
            --text-primary: #333333;
            --text-secondary: rgba(0, 0, 0, 0.7);
            --border-color: rgba(0, 0, 0, 0.1);
        }

        body {
            background: var(--primary-bg);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            padding: clamp(10px, 2vw, 20px);
            overscroll-behavior: none;
            transition: background 0.3s ease;
        }

        /* Base Container Styles */
        .container,
        .file-select-container,
        .receive-container,
        .transfer-popup,
        .qr-container,
        .settings-container,
        .connection-id-container,
        .enter-connection-container {
            text-align: center;
            padding: clamp(20px, 4vw, 40px);
            background: var(--card-bg);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border-radius: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            width: 96%;
            margin-top: clamp(40px, 8vw, 60px);
            max-width: clamp(300px, 40vw, 500px);
            border: 1px solid var(--border-color);
            margin-bottom: clamp(10px, 2vw, 20px);
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease-in-out;
            will-change: transform, opacity;
            transform: translate3d(0, 0, 0);
        }

        .container:not(.active),
        .file-select-container:not(.active),
        .receive-container:not(.active),
        .transfer-popup:not(.active),
        .qr-container:not(.active),
        .settings-container:not(.active),
        .connection-id-container:not(.active),
        .enter-connection-container:not(.active) {
            display: none;
            opacity: 0;
            transform: translateY(20px);
        }

        .container.active,
        .file-select-container.active,
        .receive-container.active,
        .transfer-popup.active,
        .qr-container.active,
        .settings-container.active,
        .connection-id-container.active,
        .enter-connection-container.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* Typography */
        h1 {
            font-size: clamp(32px, 5vw, 50px);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.5px;
            margin-bottom: 8px;
        }

        h2 {
            font-size: clamp(18px, 2vw, 24px);
            font-family: 'Exo 2', sans-serif;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.3px;
            margin-bottom: 12px;
        }

        h3 {
            color: var(--text-primary);
            font-size: clamp(24px, 3vw, 30px);
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 15px;
        }

        p {
            font-size: clamp(16px, 2vw, 22px);
            font-family: 'Russo One', sans-serif;
            color: var(--text-secondary);
            margin-bottom: clamp(15px, 3vw, 25px);
            line-height: 1.5;
        }

        /* Buttons */
        .button {
            display: block;
            width: 100%;
            padding: clamp(12px, 2.5vw, 18px);
            margin: 10px 0;
            border-radius: 14px;
            font-size: clamp(18px, 2vw, 24px);
            font-family: 'Bebas Neue', sans-serif;
            font-weight: 700;
            cursor: pointer;
            border: none;
            color: white;
            background: var(--primary-accent);
            box-shadow: inset 0 2px 5px rgba(255, 255, 255, 0.2), 0 4px 10px rgba(0, 0, 0, 0.3),
                inset 0px 0px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform, box-shadow;
            transform: translate3d(0, 0, 0);
        }

        .button:hover {
            background: linear-gradient(145deg, #4471e5, #1c47c1);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5), inset 0px 0px 10px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        .button:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .button-receive {
            background: var(--secondary-accent);
        }

        .button-receive:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
        }

        .button-settings {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--card-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 10px var(--shadow-color);
            transition: transform 0.3s ease, background 0.3s ease;
        }

        .button-settings:hover {
            transform: rotate(30deg);
        }

        .button-settings i {
            color: var(--text-primary);
            font-size: 24px;
        }

        /* File Selection Container Styles */
        .file-select-container {
            overflow: hidden;
        }

        .file-select-container input[type="file"] {
            display: none;
        }

        .file-select-container label {
            background: var(--secondary-accent);
            padding: clamp(10px, 2vw, 14px);
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            display: inline-block;
            margin-bottom: 20px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
            will-change: background;
            transform: translate3d(0, 0, 0);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .file-select-container label:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
            transform: scale(1.05);
        }

        .file-drop-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            transition: background 0.3s ease, border-color 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .file-drop-area.drag-over {
            background: rgba(255, 255, 255, 0.1);
            border-color: #7c6bff;
        }

        .file-drop-area i {
            font-size: 40px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .file-drop-area p {
            margin-bottom: 0;
        }

        .file-list {
            text-align: left;
            margin-bottom: 20px;
            overflow-y: auto;
            max-height: 200px;
            padding-right: 10px;
        }

        .file-list li {
            font-size: clamp(14px, 1.6vw, 18px);
            font-family: 'Russo One', sans-serif;
            color: var(--text-secondary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            will-change: color, transform;
            transform: translate3d(0, 0, 0);
            padding: 8px;
            border-radius: 8px;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), background-color 0.3s ease;
        }

        .file-list li:hover {
            background-color: rgba(255, 255, 255, 0.05);
            transform: translateY(-2px);
        }

        .file-list li .file-icon {
            margin-right: 5px;
        }

        .file-list li .remove-file {
            cursor: pointer;
            color: var(--error-color);
            transition: color 0.3s ease;
        }

        .file-list li .remove-file:hover {
            color: #ff4d6a;
        }

        .file-select-container button {
            background: var(--primary-accent);
            padding: clamp(10px, 2vw, 14px);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .file-select-container button:hover {
            background: linear-gradient(145deg, #4471e5, #1c47c1);
            transform: scale(1.03);
        }

        /* Receive Container Styles */
        .receive-container p {
            font-size: clamp(16px, 2vw, 22px);
            font-family: 'Russo One', sans-serif;
            color: var(--text-secondary);
            margin-bottom: clamp(15px, 3vw, 25px);
            line-height: 1.5;
        }

        .receive-container button {
            background: var(--secondary-accent);
            padding: clamp(10px, 2vw, 14px);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: transform 0.3s ease, background 0.3s ease;
        }

        .receive-container button:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
            transform: scale(1.03);
        }

        .file-preview {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }

        .file-preview i {
            margin-right: 10px;
            color: var(--text-primary);
        }

        .file-preview-info {
            flex: 1;
            text-align: left;
        }

        .file-preview-name {
            font-size: 18px;
            color: var(--text-primary);
        }

        .file-preview-size {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .file-preview-image {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 10px;
            object-fit: contain;
        }

        .action-buttons {
            display: flex;
            justify-content: space-around;
        }

        .action-buttons button {
            flex: 1;
            margin: 0 5px;
        }

        .action-buttons button.decline {
            background: var(--error-color);
        }

        .action-buttons button.decline:hover {
            background: #e74c3c;
        }

        /* File Transfer Popup Styles */
        .transfer-popup {
            overflow: hidden;
        }

        .progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #3a69d4, #7c6bff);
            border-radius: 5px;
            transition: width 0.2s ease-out;
            will-change: width;
            transform: translate3d(0, 0, 0);
        }

        .transfer-status {
            font-size: clamp(16px, 2vw, 20px);
            font-family: 'Russo One', sans-serif;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        .transfer-details {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        #cancelBtn {
            background: var(--secondary-accent);
            padding: clamp(10px, 2vw, 14px);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        #cancelBtn:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
            transform: scale(1.03);
        }

        #transferringList {
            text-align: left;
            margin-bottom: 20px;
            overflow-y: auto;
            max-height: 150px;
            padding-right: 10px;
        }

        #transferringList li {
            font-size: clamp(14px, 1.6vw, 18px);
            font-family: 'Russo One', sans-serif;
            color: var(--text-secondary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            will-change: color, transform;
            transform: translate3d(0, 0, 0);
            padding: 8px;
            border-radius: 8px;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), background-color 0.3s ease;
        }

        #transferringList li:hover {
            background-color: rgba(255, 255, 255, 0.05);
            transform: translateY(-2px);
        }

        .file-progress {
            width: 100%;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .file-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3a69d4, #7c6bff);
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }

        /* QR Code Container Styles */
        .qr-container {
            text-align: center;
        }

        .qr-code-wrapper {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 20px;
        }

        #qrCode {
            width: 200px;
            height: 200px;
        }

        .connection-id {
            font-family: 'Orbitron', sans-serif;
            color: var(--text-primary);
            font-size: 18px;
            margin-bottom: 20px;
            word-break: break-all;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
        }

        /* Settings Container Styles */
        .settings-container {
            text-align: left;
        }

        .settings-option {
            margin-bottom: 20px;
        }

        .settings-option label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 18px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #7c6bff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .select-wrapper {
            position: relative;
            width: 100%;
        }

        .select-wrapper select {
            appearance: none;
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            font-size: 16px;
            cursor: pointer;
        }

        .select-wrapper:after {
            content: '\f078';
            font-family: 'Font Awesome 5 Free';
            font-weight: 900;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-primary);
            pointer-events: none;
        }

        /* Incoming File Alert Styles */
        .incoming-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: clamp(10px, 2vw, 15px);
            border-radius: 8px;
            z-index: 1001;
            font-family: 'SF Pro Display', sans-serif;
            font-size: clamp(16px, 1.8vw, 18px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .incoming-alert.active {
            display: block;
            animation: slideDown 0.5s ease-out, fadeOut 3s forwards 3s;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1001;
            font-family: 'SF Pro Display', sans-serif;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .toast.active {
            display: block;
            animation: fadeIn 0.3s ease-out, fadeOut 3s forwards 2s;
        }

        .toast.success {
            background: rgba(40, 167, 69, 0.9);
        }

        .toast.error {
            background: rgba(220, 53, 69, 0.9);
        }

        .toast.warning {
            background: rgba(255, 193, 7, 0.9);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        /* Connection Status Indicator */
        .connection-status {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            font-size: 14px;
            color: var(--text-primary);
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-indicator.connected {
            background-color: var(--success-color);
            box-shadow: 0 0 5px var(--success-color);
        }

        .status-indicator.disconnected {
            background-color: var(--error-color);
            box-shadow: 0 0 5px var(--error-color);
        }

        .status-indicator.connecting {
            background-color: var(--warning-color);
            box-shadow: 0 0 5px var(--warning-color);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0.5;
            }
        }

        /* File Type Icons */
        .file-type-icon i {
            font-size: 20px;
        }

        .file-type-icon.image {
            background: linear-gradient(135deg, #ff9a9e, #fad0c4);
        }

        .file-type-icon.document {
            background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
        }

        .file-type-icon.video {
            background: linear-gradient(135deg, #ffecd2, #fcb69f);
        }

        .file-type-icon.audio {
            background: linear-gradient(135deg, #a18cd1, #fbc2eb);
        }

        .file-type-icon.archive {
            background: linear-gradient(135deg, #84fab0, #8fd3f4);
        }

        .file-type-icon.code {
            background: linear-gradient(135deg, #cfd9df, #e2ebf0);
        }

        /* ✅ Fully Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container,
            .file-select-container,
            .receive-container,
            .transfer-popup,
            .qr-container,
            .settings-container,
            .connection-id-container,
            .enter-connection-container {
                max-width: 95%;
            }

            h1 {
                font-size: 36px;
            }

            h2 {
                font-size: 20px;
        }

        p {
            font-size: 18px;
        }

        .button {
            font-size: 20px;
        }
    }

    @media (max-width: 480px) {
        h1 {
            font-size: 32px;
        }

        h2 {
            font-size: 18px;
        }

        p {
            font-size: 16px;
        }

        .button {
            font-size: 18px;
        }

        .button-settings {
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
        }

        .button-settings i {
            font-size: 20px;
        }
    }

    /* PWA Styles */
    @media (display-mode: standalone) {
        body {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
    }

    /* Error Handling Styles */
    .error-container {
        background-color: var(--error-color);
        color: white;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: left;
    }

    .error-title {
        font-weight: bold;
        margin-bottom: 5px;
    }

    .error-message {
        font-size: 14px;
    }

    .retry-button {
        background: white;
        color: var(--error-color);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        margin-top: 10px;
        cursor: pointer;
    }

    /* Connection ID Input Container Styles */
    .enter-connection-container {
        text-align: center;
    }

    .enter-connection-container input[type="text"] {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background-color: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
        font-size: 16px;
        margin-bottom: 15px;
    }
</style>
<!-- Temporary styling -->
<style>
    /* TEMPORARY: Remove visibility override */
    .container,
    .file-select-container,
    .receive-container,
    .transfer-popup,
    .qr-container,
    .settings-container,
    .connection-id-container,
    .enter-connection-container {
        display: none;
        /* Reset to default */
    }

    .container.active,
    .file-select-container.active,
    .receive-container.active,
    .transfer-popup.active,
    .qr-container.active,
    .settings-container.active,
    .connection-id-container.active,
    .enter-connection-container.active {
        display: block !important;
        /* Override any 'display: none' */
        opacity: 1 !important;
        /* Ensure full visibility */
        transform: translateY(0) !important;
        /* Remove any translation */
    }
</style>
</head>
<body class="dark">
<div class="connection-status" id="connectionStatus">
<div class="status-indicator disconnected" id="statusIndicator"></div>
<span id="statusText">Disconnected</span>
</div>
<!-- Main Container -->
<div class="container active" id="mainContainer">
    <div class="button-settings" id="settingsBtn">
        <i class="fas fa-cog"></i>
    </div>
    <h1>BlueDrop</h1>
    <h2>Effortless File Transfers</h2>
    <p>Share files instantly with just a tap. Secure, fast, and designed for a seamless experience.</p>
    <button class="button" id="sendBtn">
        <i class="fas fa-upload"></i> Send Files
    </button>
    <button class="button button-receive" id="receiveBtn">
        <i class="fas fa-download"></i> Receive Files
    </button>
</div>

<!-- File Selection Container -->
<div class="file-select-container" id="fileSelectContainer">
    <h3>Select Files to Send</h3>

    <div class="file-drop-area" id="dropArea">
        <i class="fas fa-cloud-upload-alt"></i>
        <p>Drag & drop files here</p>
    </div>

    <input type="file" id="fileInput" multiple>
    <label for="fileInput">
        <i class="fas fa-plus-circle"></i> Choose Files
    </label>
    <ul class="file-list" id="fileList"></ul>
    <button id="initiateTransferBtn">
        <i class="fas fa-paper-plane"></i> Start Transfer
    </button>
    <button class="button" id="backFromFileSelectBtn">
        <i class="fas fa-arrow-left"></i> Back
    </button>
</div>

<!-- Enter Connection ID Container (Sender) -->
<div class="enter-connection-container" id="enterConnectionContainer">
    <h3>Enter Receiver's Connection ID</h3>
    <input type="text" id="receiverConnectionInput" placeholder="Paste connection ID here">
    <button class="button" id="connectToReceiverBtn">Connect</button>
</div>

<!-- QR Code Container (Receiver) -->
<div class="qr-container" id="qrContainer">
    <h3>Receiver Setup</h3>
    <p>Choose connection method:</p>
    <button class="button" id="showQRCodeBtn">Show QR Code</button>
    <button class="button" id="showConnectionIdBtn">Show Connection ID</button>
</div>

<!-- Connection ID Container (Receiver) -->
<div class="qr-container" id="connectionIdContainer">
    <h3>Your Connection ID</h3>
    <p>Give this ID to the sender:</p>
    <div class="connection-id" id="connectionIdDisplay">Generating ID...</div>
    <button class="button" id="backFromConnectionIdBtn">Back</button>
</div>

<!-- QR Code Display Container (Receiver) -->
<div class="qr-container" id="qrCodeContainer">
    <h3>Scan to Connect</h3>
    <p>Scan this QR code with the sender's device</p>
    <div class="qr-code-wrapper">
        <div id="qrCode"></div>
    </div>

    <button class="button" id="backFromQrCodeBtn">
        <i class="fas fa-arrow-left"></i> Back
    </button>
</div>

<!-- Receive Container -->
<div class="receive-container" id="receiveContainer">
    <h3>Incoming Transfer</h3>
    <p>Someone wants to share files with you.</p>

    <div class="file-preview">
        <i class="fas fa-file fa-3x" id="fileTypeIcon"></i>
        <div class="file-preview-info">
            <div class="file-preview-name" id="incomingFileName"></div>
            <div class="file-preview-size" id="incomingFileSize"></div>
        </div>
    </div>

    <div id="filePreviewImage" style="display: none;">
        <img id="previewImage" class="file-preview-image" alt="File preview">
    </div>

    <div class="action-buttons">
        <button id="acceptBtn">
            <i class="fas fa-check"></i> Accept
        </button>
        <button class="decline" id="declineBtn">
            <i class="fas fa-times"></i> Decline
        </button>
    </div>
</div>

<!-- File Transfer Popup -->
<div class="transfer-popup" id="transferPopup">
    <h3>Transferring Files...</h3>
    <ul id="transferringList"></ul>
    <div class="progress-bar-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="transfer-details">
        <span id="transferSpeed">0 KB/s</span>
        <span id="transferRemaining">Calculating...</span>
    </div>
    <p class="transfer-status" id="transferStatus"></p>
    <button id="cancelBtn">Cancel</button>
</div>

<!-- Settings Container -->
<div class="settings-container" id="settingsContainer">
    <h3>Settings</h3>

    <div class="settings-option">
        <label for="darkModeToggle">Dark Mode</label>
        <label class="toggle-switch">
            <input type="checkbox" id="darkModeToggle" checked>
            <span class="toggle-slider"></span>
        </label>
    </div>

    <div class="settings-option">
        <label for="encryptionToggle">End-to-End Encryption</label>
        <label class="toggle-switch">
            <input type="checkbox" id="encryptionToggle" checked>
            <span class="toggle-slider"></span>
        </label>
    </div>

    <div class="settings-option">
        <label for="compressionToggle">File Compression</label>
        <label class="toggle-switch">
            <input type="checkbox" id="compressionToggle" checked>
            <span class="toggle-slider"></span>
        </label>
    </div>

    <div class="settings-option">
        <label for="chunkSizeSelect">Chunk Size</label>
        <div class="select-wrapper">
            <select id="chunkSizeSelect">
                <option value="16384">16 KB (Default)</option>
                <option value="32768">32 KB</option>
                <option value="65536">64 KB</option>
                <option value="131072">128 KB</option>
            </select>
        </div>
    </div>

    <div class="settings-option">
        <label for="saveLocationSelect">Default Save Location</label>
        <div class="select-wrapper">
            <select id="saveLocationSelect">
                <option value="downloads">Downloads Folder</option>
                <option value="custom">Choose Location</option>
            </select>
        </div>
    </div>

    <button class="button" id="saveSettingsBtn">
        <i class="fas fa-save"></i> Save Settings
    </button>
    <button class="button" id="backFromSettingsBtn">
        <i class="fas fa-arrow-left"></i> Back
    </button>
</div>

<!-- Incoming File Alert -->
<div class="incoming-alert" id="incomingAlert">
    Incoming File Transfer!
</div>

<!-- Toast Notification -->
<div class="toast" id="toast"></div>

<script>
    // DOM Elements
    const mainContainer = document.getElementById("mainContainer");
    const sendBtn = document.getElementById("sendBtn");
    const receiveBtn = document.getElementById("receiveBtn");
    const fileSelectContainer = document.getElementById("fileSelectContainer");
    const receiveContainer = document.getElementById("receiveContainer");
    const transferPopup = document.getElementById("transferPopup");
    const qrContainer = document.getElementById("qrContainer");
    const settingsContainer = document.getElementById("settingsContainer");
    const settingsBtn = document.getElementById("settingsBtn");
    const progressBar = document.getElementById("progressBar");
    const transferStatus = document.getElementById("transferStatus");
    const transferSpeed = document.getElementById("transferSpeed");
    const transferRemaining = document.getElementById("transferRemaining");
    const cancelBtn = document.getElementById("cancelBtn");
    const incomingAlert = document.getElementById("incomingAlert");
    const fileInput = document.getElementById("fileInput");
    const fileList = document.getElementById("fileList");
    const transferringList = document.getElementById("transferringList");
    const incomingFileNameDisplay = document.getElementById("incomingFileName");
    const incomingFileSizeDisplay = document.getElementById("incomingFileSize");
    const filePreviewImage = document.getElementById("filePreviewImage");
    const previewImage = document.getElementById("previewImage");
    const dropArea = document.getElementById("dropArea");
    const qrCodeElement = document.getElementById("qrCode");
    const connectionIdElement = document.getElementById("connectionIdDisplay"); // Updated ID
    const toast = document.getElementById("toast");
    const fileTypeIcon = document.getElementById("fileTypeIcon");
    const connectionStatus = document.getElementById("connectionStatus");
    const statusIndicator = document.getElementById("statusIndicator");
    const statusText = document.getElementById("statusText");

    // Settings Elements
    const darkModeToggle = document.getElementById("darkModeToggle");
    const encryptionToggle = document.getElementById("encryptionToggle");
    const compressionToggle = document.getElementById("compressionToggle");
    const chunkSizeSelect = document.getElementById("chunkSizeSelect");
    const saveLocationSelect = document.getElementById("saveLocationSelect");
    const enterConnectionContainer = document.getElementById("enterConnectionContainer");
    const receiverConnectionInput = document.getElementById("receiverConnectionInput");
    const qrCodeContainer = document.getElementById("qrCodeContainer");
    const connectionIdContainer = document.getElementById("connectionIdContainer");

    const backFromFileSelectBtn = document.getElementById("backFromFileSelectBtn");
    const backFromQrCodeBtn = document.getElementById("backFromQrCodeBtn");
    const backFromConnectionIdBtn = document.getElementById("backFromConnectionIdBtn");
    const backFromSettingsBtn = document.getElementById("backFromSettingsBtn");

    const initiateTransferBtn = document.getElementById("initiateTransferBtn");
    const connectToReceiverBtn = document.getElementById("connectToReceiverBtn");
    const showQRCodeBtn = document.getElementById("showQRCodeBtn");
    const showConnectionIdBtn = document.getElementById("showConnectionIdBtn");
    const acceptBtn = document.getElementById("acceptBtn");
    const declineBtn = document.getElementById("declineBtn");
    const saveSettingsBtn = document.getElementById("saveSettingsBtn");




    // Application State
    let selectedFiles = [];
    let intervals = [];
    let transferOngoing = false;
    let transferStartTime = 0;
    let totalBytesTransferred = 0;
    let totalBytes = 0;
    let currentChunkSize = 16384; // Default 16KB
    let useEncryption = true;
    let useCompression = true;
    let darkMode = true;
    let saveLocation = "downloads";
    let retryCount = 0;
    let maxRetries = 3;
    let connectionTimeout = null;
    let receiverId; // Unique receiver ID for signaling

    // WebRTC variables
    let peer;
    let initiator = false;
    let receivedFileData = [];
    let incomingFileMeta = null;
    let connectionId = generateConnectionId();
    let encryptionKey = null;
    let peerConnected = false;
    let reconnectInterval = null;
    let receiverSignalData = null;  //For storing receiver's signal data


    // Initialize the application
    function initApp() {
        // Load settings from localStorage
        loadSettings();

        // Apply dark/light mode
        applyTheme();

        // Initialize IndexedDB
        initIndexedDB();

        // Set up event listeners
        setupEventListeners();

        // Check if app is installed as PWA
        checkIfPWA();

        // Check for browser compatibility
        checkBrowserCompatibility();

        // Show welcome toast
        showToast("Welcome to BlueDrop!", "success");

        //Generate receiver Id
        receiverId = generateConnectionId();


    }

    // Check browser compatibility
    function checkBrowserCompatibility() {
        // Check for WebRTC support
        if (!window.RTCPeerConnection || !navigator.mediaDevices) {
            showToast("Your browser may not fully support WebRTC. Some features might not work correctly.",
                "warning");
        }

        // Check for IndexedDB support
        if (!window.indexedDB) {
            showToast("Your browser doesn't support IndexedDB. File storage will be limited.", "warning");
        }

        // Check for File API support
        if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
            showToast(
                "Your browser doesn't fully support the File API. File handling may be limited.",
                "warning");
        }
    }

    // Load settings from localStorage
    function loadSettings() {
        if (localStorage.getItem("bluedrop-settings")) {
            try {
                const settings = JSON.parse(localStorage.getItem("bluedrop-settings"));
                darkMode = settings.darkMode !== undefined ? settings.darkMode : true;
                useEncryption = settings.useEncryption !== undefined ? settings.useEncryption : true;
                useCompression = settings.useCompression !== undefined ? settings.useCompression : true;
                currentChunkSize = settings.chunkSize || 16384;
                saveLocation = settings.saveLocation || "downloads";

                // Update UI to reflect settings
                darkModeToggle.checked = darkMode;
                encryptionToggle.checked = useEncryption;
                compressionToggle.checked = useCompression;
                chunkSizeSelect.value = currentChunkSize.toString();
                saveLocationSelect.value = saveLocation;
            } catch (error) {
                console.error("Error loading settings:", error);
                // Reset to defaults if there's an error
                resetSettings();
            }
        }
    }

    // Reset settings to defaults
    function resetSettings() {
        darkMode = true;
        useEncryption = true;
        useCompression = true;
        currentChunkSize = 16384;
        saveLocation = "downloads";

        darkModeToggle.checked = darkMode;
        encryptionToggle.checked = useEncryption;
        compressionToggle.checked = useCompression;
        chunkSizeSelect.value = currentChunkSize.toString();
        saveLocationSelect.value = saveLocation;

        saveSettings();
    }

    // Save settings to localStorage
    function saveSettings() {
        darkMode = darkModeToggle.checked;
        useEncryption = encryptionToggle.checked;
        useCompression = compressionToggle.checked;
        currentChunkSize = parseInt(chunkSizeSelect.value);
        saveLocation = saveLocationSelect.value;

        const settings = {
            darkMode,
            useEncryption,
            useCompression,
            chunkSize: currentChunkSize,
            saveLocation
        };

        try {
            localStorage.setItem("bluedrop-settings", JSON.stringify(settings));

            // Apply theme
            applyTheme();

            // Show confirmation
            showToast("Settings saved successfully!", "success");

            // Return to main screen
            hideSettingsContainer();
            showMainContainer();
        } catch (error) {
            console.error("Error saving settings:", error);
            showToast("Failed to save settings", "error");
        }
    }

    // Apply theme based on settings
    function applyTheme() {
        if (darkMode) {
            document.body.classList.add("dark");
            document.body.classList.remove("light");
        } else {
            document.body.classList.add("light");
            document.body.classList.remove("dark");
        }
    }

    // Check if app is installed as PWA
    function checkIfPWA() {
        if (window.matchMedia('(display-mode: standalone)').matches) {
            // App is running as PWA
            showToast("Running as installed app", "success");
        }
    }

    // Set up event listeners
    function setupEventListeners() {
        // Settings button
        settingsBtn.addEventListener("click", () => {
            hideAllContainers();
            showSettingsContainer();
        });

        // Drag and drop functionality
        dropArea.addEventListener("dragover", (e) => {
            e.preventDefault();
            dropArea.classList.add("drag-over");
        });

        dropArea.addEventListener("dragleave", () => {
            dropArea.classList.remove("drag-over");
        });

        dropArea.addEventListener("drop", (e) => {
            e.preventDefault();
            dropArea.classList.remove("drag-over");

            if (e.dataTransfer.files.length > 0) {
                selectedFiles = Array.from(e.dataTransfer.files);
                renderFileList();
            }
        });

        // File list event delegation for remove buttons
        fileList.addEventListener("click", (event) => {
            if (event.target.classList.contains("remove-file") ||
                event.target.parentElement.classList.contains("remove-file")) {
                const fileName = event.target.dataset.name || event.target.parentElement.dataset.name;
                selectedFiles = selectedFiles.filter(file => file.name !== fileName);
                renderFileList();
            }
        });

        // Handle visibility change to manage connections
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") {
                // Page is visible again, check connection
                if (peer && !peerConnected) {
                    reconnectPeer();
                }
            }
        });

        // Handle online/offline events
        window.addEventListener("online", () => {
            showToast("You're back online", "success");
            if (peer && !peerConnected) {
                reconnectPeer();
            }
        });

        window.addEventListener("offline", () => {
            showToast("You're offline. Connection lost.", "error");
            updateConnectionStatus("disconnected", "Offline");
        });

        // Handle beforeunload to warn about active transfers
        window.addEventListener("beforeunload", (e) => {
            if (transferOngoing) {
                const message =
                    "You have an active file transfer. Are you sure you want to leave?";
                e.returnValue = message;
                return message;
            }
        });

        // Button Event Listeners

        sendBtn.addEventListener("click", openFileSelect);
        receiveBtn.addEventListener("click", openReceiverSetup);
        backFromFileSelectBtn.addEventListener("click", showMainContainer);
        backFromQrCodeBtn.addEventListener("click", showMainContainer);
        backFromConnectionIdBtn.addEventListener("click", showMainContainer);
        backFromSettingsBtn.addEventListener("click", showMainContainer);

        initiateTransferBtn.addEventListener("click", initiateTransferProcess);
        connectToReceiverBtn.addEventListener("click", connectToReceiver);
        showQRCodeBtn.addEventListener("click", showQRCodeContainer);
        showConnectionIdBtn.addEventListener("click", showConnectionIdContainer);
        acceptBtn.addEventListener("click", acceptTransfer);
        declineBtn.addEventListener("click", declineTransfer);
        saveSettingsBtn.addEventListener("click", saveSettings);

        fileInput.addEventListener("change", handleFileSelection);

    }

    // IndexedDB setup
    let db;
    const dbName = "BlueDropDB";
    const objectStoreName = "files";

    function initIndexedDB() {
        try {
            const request = indexedDB.open(dbName, 1);

            request.onerror = function(event) {
                console.error("Database error: " + event.target.errorCode);
                showToast("Failed to initialize database", "error");
            };

            request.onupgradeneeded = function(event) {
                db = event.target.result;
                const objectStore = db.createObjectStore(objectStoreName, {
                    keyPath: "id"
                });
                objectStore.createIndex("name", "name", {
                    unique: false
                });
                objectStore.createIndex("category", "category", {
                    unique: false
                });
                objectStore.createIndex("timestamp", "timestamp", {
                    unique: false
                });
            };

            request.onsuccess = function(event) {
                db = event.target.result;
                console.log("IndexedDB initialized successfully");

                // Set up error handling for database
                db.onerror = function(event) {
                    console.error("Database error: " + event.target.errorCode);
                    showToast("Database error occurred", "error");
                };
            };
        } catch (error) {
            console.error("Error initializing IndexedDB:", error);
            showToast("Failed to initialize database: " + error.message, "error");
        }
    }

    // Function to store file in IndexedDB
    function storeFileInIndexedDB(file, fileData, category = 'Uncategorized') {
        return new Promise((resolve, reject) => {
            if (!db) {
                reject(new Error("Database not initialized"));
                return;
            }

            try {
                const transaction = db.transaction([objectStoreName], "readwrite");
                const objectStore = transaction.objectStore(objectStoreName);

                const fileObject = {
                    id: generateUUID(),
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    data: fileData,
                    category: category || categorizeFile(file.name),
                    timestamp: Date.now()
                };

                const request = objectStore.add(fileObject);

                request.onsuccess = () => {
                    resolve(fileObject.id);
                };

                request.onerror = (event) => {
                    console.error("IndexedDB store error:", event.target.error);
                    reject(new Error("Failed to store file in IndexedDB"));
                };

                transaction.oncomplete = () => {
                    console.log("Transaction completed successfully");
                };

                transaction.onerror = (event) => {
                    console.error("Transaction error:", event.target.error);
                    reject(new Error("Transaction failed"));
                };
            } catch (error) {
                console.error("Error in storeFileInIndexedDB:", error);
                reject(error);
            }
        });
    }

    // Function to retrieve file from IndexedDB
    function retrieveFileFromIndexedDB(fileId) {
        return new Promise((resolve, reject) => {
            if (!db) {
                reject(new Error("Database not initialized"));
                return;
            }

            try {
                const transaction = db.transaction([objectStoreName], "readonly");
                const objectStore = transaction.objectStore(objectStoreName);
                const request = objectStore.get(fileId);

                request.onsuccess = () => {
                    if (request.result) {
                        resolve(request.result);
                    } else {
                        reject(new Error("File not found in IndexedDB"));
                    }
                };

                request.onerror = (event) => {
                    console.error("IndexedDB retrieve error:", event.target.error);
                    reject(new Error("Failed to retrieve file from IndexedDB"));
                };
            } catch (error) {
                console.error("Error in retrieveFileFromIndexedDB:", error);
                reject(error);
            }
        });
    }

    // Generate a UUID
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    // Generate a connection ID
    function generateConnectionId() {
        return Math.random().toString(36).substring(2, 10);
    }

    // Clear all intervals
    function clearAllIntervals() {
        intervals.forEach(interval => clearInterval(interval));
        intervals = [];
    }

    // Format bytes to human-readable size
    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];

        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Show toast notification
    function showToast(message, type = "") {
        toast.textContent = message;
        toast.className = "toast active";

        if (type) {
            toast.classList.add(type);
        }

        setTimeout(() => {
            toast.classList.remove("active");
            setTimeout(() => {
                toast.className = "toast"; // Reset all classes
            }, 300);
        }, 3000);
    }

    // Update connection status indicator
    function updateConnectionStatus(status, message = "") {
        statusIndicator.className = "status-indicator " + status;

        switch (status) {
            case "connected":
                statusText.textContent = message || "Connected";
                peerConnected = true;
                break;
            case "disconnected":
                statusText.textContent = message || "Disconnected";
                peerConnected = false;
                break;
            case "connecting":
                statusText.textContent = message || "Connecting...";
                peerConnected = false;
                break;
            default:
                statusText.textContent = status;
                break;
        }
    }

    // AI-powered file categorization
    function categorizeFile(fileName) {
        const lowerCaseName = fileName.toLowerCase();
        const extension = lowerCaseName.split('.').pop();

        const categories = {
            documents: ['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt', 'xls', 'xlsx', 'ppt', 'pptx'],
            images: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'heic', 'heif', 'raw'],
            videos: ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', 'm4v', '3gp'],
            audio: ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'wma'],
            archives: ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'],
            code: ['js', 'html', 'css', 'py', 'java', 'c', 'cpp', 'php', 'rb', 'go', 'ts', 'jsx', 'tsx']
        };

        for (const [category, extensions] of Object.entries(categories)) {
            if (extensions.includes(extension)) {
                return category.charAt(0).toUpperCase() + category.slice(1);
            }
        }

        return 'Uncategorized';
    }

    // Get file icon based on file type
    function getFileIcon(fileName) {
        const extension = fileName.split('.').pop().toLowerCase();

        // Document types
        if (['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'].includes(extension)) {
            return '<i class="fas fa-file-alt"></i>';
        }
        // Spreadsheet types
        else if (['xls', 'xlsx', 'csv'].includes(extension)) {
            return '<i class="fas fa-file-excel"></i>';
        }
        // Presentation types
        else if (['ppt', 'pptx'].includes(extension)) {
            return '<i class="fas fa-file-powerpoint"></i>';
        }
        // Image types
        else if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(extension)) {
            return '<i class="fas fa-file-image"></i>';
        }
        // Video types
        else if (['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv'].includes(extension)) {
            return '<i class="fas fa-file-video"></i>';
        }
        // Audio types
        else if (['mp3', 'wav', 'ogg', 'flac', 'aac'].includes(extension)) {
            return '<i class="fas fa-file-audio"></i>';
        }
        // Archive types
        else if (['zip', 'rar', '7z', 'tar', 'gz'].includes(extension)) {
            return '<i class="fas fa-file-archive"></i>';
        }
        // Code types
        else if (['js', 'html', 'css', 'py', 'java', 'c', 'cpp', 'php'].includes(extension)) {
            return '<i class="fas fa-file-code"></i>';
        }
        // Default
        else {
            return '<i class="fas fa-file"></i>';
        }
    }

    // Encrypt data using AES
    async function encryptData(data, key) {
        if (!useEncryption) return {
            data,
            key: null
        };

        try {
            // If key is not provided, generate one
            if (!key) {
                key = CryptoJS.lib.WordArray.random(16).toString();
            }

            // Convert ArrayBuffer to WordArray
            let wordArray;
            if (data instanceof ArrayBuffer) {
                wordArray = CryptoJS.lib.WordArray.create(new Uint8Array(data));
            } else if (typeof data === 'string') {
                wordArray = data;
            } else {
                // Handle Uint8Array or other array types
                wordArray = CryptoJS.lib.WordArray.create(data);
            }

            // Encrypt the data
            const encrypted = CryptoJS.AES.encrypt(wordArray, key).toString();

            return {
                data: encrypted,
                key: key
            };
        } catch (error) {
            console.error("Encryption error:", error);
            showToast("Encryption failed: " + error.message, "error");
            return {
                data,
                key: null
            };
        }
    }

    // Decrypt data using AES
    async function decryptData(encryptedData, key) {
        if (!useEncryption) return encryptedData;

        try {
            // Decrypt the data
            const decrypted = CryptoJS.AES.decrypt(encryptedData, key);

            // Convert WordArray to string
            return decrypted.toString(CryptoJS.enc.Utf8);
        } catch (error) {
            console.error("Decryption error:", error);
            showToast("Decryption failed: " + error.message, "error");
            return encryptedData;
        }
    }

    // Compress data using pako
    function compressData(data) {
        if (!useCompression) return data;

        try {
            // Convert data to Uint8Array if it's an ArrayBuffer
            let dataArray;
            if (data instanceof ArrayBuffer) {
                dataArray = new Uint8Array(data);
            } else if (typeof data === 'string') {
                                   // Convert string to Uint8Array
                const encoder = new TextEncoder();
                dataArray = encoder.encode(data);
            } else {
                dataArray = data;
            }

            // Compress the data
            const compressed = pako.deflate(dataArray);

            return compressed.buffer;
        } catch (error) {
            console.error("Compression error:", error);
            showToast("Compression failed: " + error.message, "error");
            return data;
        }
    }

    // Decompress data using pako
    function decompressData(compressedData) {
        if (!useCompression) return compressedData;

        try {
            // Convert data to Uint8Array if it's an ArrayBuffer
            let dataArray;
            if (compressedData instanceof ArrayBuffer) {
                dataArray = new Uint8Array(compressedData);
            } else {
                dataArray = compressedData;
            }

            // Decompress the data
            const decompressed = pako.inflate(dataArray);

            return decompressed.buffer;
        } catch (error) {
            console.error("Decompression error:", error);
            showToast("Decompression failed: " + error.message, "error");
            return compressedData;
        }
    }

    // Convert file to ArrayBuffer
    function fileToArrayBuffer(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsArrayBuffer(file);
        });
    }

    /**
     * ------CONNECTION HANDLER------
     */

    // -- General Functions --
    function updateConnectionStatus(status, message = "") {
        statusIndicator.className = "status-indicator " + status;
        statusText.textContent = message;
    }

    // -- Receiver Setup --
    function openReceiverSetup() {
        hideAllContainers();
        qrContainer.classList.add('active');
    }

    function showQRCodeContainer() {
        hideAllContainers();
        qrCodeContainer.classList.add('active');
        generateAndDisplayQRCode();
    }

    function showConnectionIdContainer() {
        hideAllContainers();
        connectionIdContainer.classList.add('active');
        connectionIdElement.textContent = receiverId; // Display the generated receiverId
    }


    function generateAndDisplayQRCode() {
        try {
            receiverSignalData = null;
            updateConnectionStatus("connecting", "Generating Connection...");

            // 1. Establish Connection
            peer = new SimplePeer({
                initiator: false, // receiver
                trickle: false
            });

            //2. Handle singaling Event
            peer.on("signal", (data) => {
                receiverSignalData = data; // Capture the signal data
                //Display on Console
                console.log("Receiver signaling data", data);

                //3. Display the QR Code
                const qrData = JSON.stringify({
                    type: "signal",
                    signal: data,
                    receiverId: receiverId
                });

                new QRCode(qrCodeElement, {
                    text: qrData,
                    width: 200,
                    height: 200,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.L
                });

                // Update connection Status
                updateConnectionStatus("connected", "QR generated");

            });

            peer.on("connect", () => {
                showToast("Connected to sender!", "success");
                updateConnectionStatus("connected", "Connected to sender");
            });

            peer.on("data", handleIncomingData);

            peer.on("close", () => {
                showToast("Connection lost.", "warning");
                updateConnectionStatus("disconnected", "Disconnected");
            });

            peer.on("error", (err) => {
                showToast("Connection error: " + err.message, "error");
                updateConnectionStatus("disconnected", "Error: " + err.message);
            });

        } catch (err) {
            console.error("Error generating QR code", err);
            showToast("Failed to generate QR Code", "error");
        }
    }

    // -- sender Setup--
    function initiateTransferProcess() {
        hideAllContainers();
        enterConnectionContainer.classList.add('active');
    }

    function connectToReceiver() {
        try {
            const receiverId = receiverConnectionInput.value.trim();
            if (!receiverId) {
                showToast("Please enter a receiver ID", "warning");
                return;
            }

            hideAllContainers();
            enterConnectionContainer.classList.remove('active');

            updateConnectionStatus("connecting", "Connecting...");

            // 1. Setup
            peer = new SimplePeer({
                initiator: true,
                trickle: false,
            });

            peer.on('signal', (data) => {
                console.log("Sender signaling data:", data);
                updateConnectionStatus("connected", "Handshaking...");

                // Mock Implementation. Ideally fetch from singnal server
                setTimeout(() => {
                    if (receiverSignalData) {
                        peer.signal(receiverSignalData);
                    } else {
                        updateConnectionStatus("disconnected", "Connection Timeout. Receiver not ready");
                        showToast("Receiver is taking too long.", "warning")
                    }
                }, 5000)
            });

            peer.on("connect", () => {
                showToast("Connected to receiver!", "success");
                updateConnectionStatus("connected", "Connected to receiver");
                startActualFileTransfer(); // Transfer Files
            });

            peer.on("data", handleIncomingData);
            peer.on("close", () => {
                showToast("Connection lost", "warning");
                updateConnectionStatus("disconnected", "Disconnected");
            });

            peer.on("error", (err) => {
                showToast("Connection error: " + err.message, "error");
                updateConnectionStatus("disconnected", "Error: " + err.message);
            });

            //connect();
        } catch (err) {
            console.error("Error connectiong", err);
            showToast("Failed to connect", "error");
        }
    }


    // -- Data Transfer --
    async function handleIncomingData(data) {
        try {
            // Check if it's a control message (JSON string)
            if (typeof data === 'string' || (data instanceof Uint8Array && data.byteLength < 1000)) {
                let message;
                try {
                    // Try to parse as JSON
                    const dataString = typeof data === 'string' ? data : new TextDecoder().decode(data);
                    if (dataString.startsWith('{') && dataString.endsWith('}')) {
                        message = JSON.parse(dataString);
                    } else {
                        // Not a JSON message, treat as file chunk
                        await processFileChunk(data);
                        return;
                    }
                } catch (e) {
                    // Not a JSON message, treat as file chunk
                    await processFileChunk(data);
                    return;
                }

                // Handle different message types
                switch (message.type) {
                    case "file-meta":
                        // Received file metadata
                        incomingFileMeta = message.meta;

                        // Update UI
                        incomingFileNameDisplay.textContent = incomingFileMeta.name;
                        incomingFileSizeDisplay.textContent = formatBytes(incomingFileMeta.size);

                        // Show file preview if it's an image
                        if (incomingFileMeta.type.startsWith('image/')) {
                            filePreviewImage.style.display = 'block';
                            previewImage.src = incomingFileMeta.preview || '';
                        } else {
                            filePreviewImage.style.display = 'none';
                        }

                        // Show incoming alert
                        showIncomingAlert();

                        // Show receive container
                        hideMainContainer();
                        showReceiveContainer();
                        break;

                    case "transfer-accepted":
                        // Receiver accepted the transfer
                        showToast("Transfer accepted", "success");

                        // Start sending files
                        startActualFileTransfer();
                        break;

                    case "transfer-declined":
                        // Receiver declined the transfer
                        showToast("Transfer declined", "error");

                        // Return to main screen
                        hideAllContainers();
                        showMainContainer();
                        break;

                    case "transfer-complete":
                        // Transfer is complete
                        showToast("Transfer complete", "success");

                        // Update UI
                        transferStatus.textContent = "Transfer Complete!";
                        progressBar.style.width = "100%";

                        // Return to main screen after a delay
                        setTimeout(() => {
                            hideAllContainers();
                            showMainContainer();
                        }, 2000);
                        break;

                    case "chunk-received":
                        // Update progress for the specific file
                        updateFileProgress(message.fileId, message.progress);
                        break;

                    case "transfer-cancelled":
                        // Transfer was cancelled by the other party
                        showToast("Transfer cancelled by the other party", "warning");

                        // Clean up
                        transferOngoing = false;
                        clearIntervalAllIntervals();

                        // Return to main screen
                        hideAllContainers();
                        showMainContainer();
                        break;

                    case "error":
                        // Error from the other party
                        showToast("Error: " + message.message, "error");
                        break;

                    case "ping":
                        // Ping to keep connection alive
                        peer.send(JSON.stringify({
                            type: "pong"
                        }));
                        break;

                    case "pong":
                        // Pong response, connection is alive
                        lastPongTime = Date.now();
                        break;
                }
            } else {
                // It's a file chunk
                await processFileChunk(data);
            }
        } catch (error) {
            console.error("Error handling incoming data:", error);
            showToast("Error processing incoming data", "error");

            // Notify the other party about the error
            if (peer && peer.connected) {
                try {
                    peer.send(JSON.stringify({
                        type: "error",
                        message: "Failed to process data"
                    }));
                } catch (e) {
                    console.error("Failed to send error message:", e);
                }
            }
        }
    }

    // Process incoming file chunk
    async function processFileChunk(data) {
        try {
            // Add chunk to received data array
            receivedFileData.push(data);

            // Update progress
            totalBytesTransferred += data.byteLength;
            const progress = Math.min(100, Math.round((totalBytesTransferred / incomingFileMeta.size) * 100));

            requestAnimationFrame(() => {
                progressBar.style.width = progress + "%";
            });

            // Update transfer status
            updateTransferStatus();

            // Send acknowledgment
            if (peer && peer.connected) {
                peer.send(JSON.stringify({
                    type: "chunk-received",
                    fileId: incomingFileMeta.id,
                    progress: progress
                }));
            }

            // Check if transfer is complete
            if (progress >= 100) {
                // Process the received file
                await processReceivedFile();
            }
        } catch (error) {
            console.error("Error processing file chunk:", error);
            showToast("Failed to process file chunk", "error");
        }
    }

    // Keep connection alive with ping/pong
    let pingInterval;
    let lastPongTime = Date.now();
    const maxPingTimeout = 10000; // 10 seconds

    function startPingPong() {
        // Clear any existing interval
        if (pingInterval) {
            clearInterval(pingInterval);
        }

        lastPongTime = Date.now();

        // Start new ping interval
        pingInterval = setInterval(() => {
            if (peer && peer.connected) {
                // Check if we've received a pong recently
                if (Date.now() - lastPongTime > maxPingTimeout) {
                    console.warn("No pong received, connection may be dead");

                    // Try to reconnect
                    reconnectPeer();

                    // Clear this interval
                    clearInterval(pingInterval);
                    return;
                }

                // Send ping
                try {
                    peer.send(JSON.stringify({
                        type: "ping"
                    }));
                } catch (e) {
                    console.error("Failed to send ping:", e);

                    // Try to reconnect
                    reconnectPeer();

                    // Clear this interval
                    clearInterval(pingInterval);
                }
            } else {
                // Peer not connected, clear interval
                clearInterval(pingInterval);
            }
        }, 5000); // Ping every 5 seconds
    }

    // Handle camera access for QR code scanning
    async function startQRScanner() {
        try {
            // Check if camera is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error("Camera access not supported in this browser");
            }

            // Request camera access
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: "environment"
                }
            });

            // Create video element
            const video = document.createElement("video");
            video.srcObject = stream;
            video.setAttribute("playsinline", true); // Required for iOS
            video.play();

            // Create canvas for QR code detection
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");

            // Set up scanning interval
            const scanInterval = setInterval(() => {
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    // Set canvas dimensions to match video
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;

                    // Draw video frame to canvas
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);

                    // Get image data for QR code detection
                    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                    // Use a QR code library to detect and decode
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height);

                    if (qrCode && qrCode.data) {
                        // Stop scanning
                        clearInterval(scanInterval);

                        // Stop camera
                        stream.getTracks().forEach(track => track.stop());

                        // Connect to peer using QR data
                        connectToPeer(qrCode.data);
                    }
                }
            }, 100);

            // Return cleanup function
            return () => {
                clearInterval(scanInterval);
                stream.getTracks().forEach(track => track.stop());
            };
        } catch (error) {
            console.error("Error accessing camera:", error);
            showToast("Failed to access camera: " + error.message, "error");
            return null;
        }
    }

    // Handle file sharing via Web Share API
    async function shareFiles() {
        if (selectedFiles.length === 0) {
            showToast("No files selected to share", "warning");
            return;
        }

        try {
            if (navigator.share && navigator.canShare) {
                // Check if we can share files
                const shareData = {
                    files: selectedFiles,
                    title: 'Files shared via BlueDrop',
                    text: 'Check out these files I shared with BlueDrop!'
                };

                if (navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                    showToast("Files shared successfully", "success");
                } else {
                    throw new Error("Files cannot be shared on this device");
                }
            } else {
                throw new Error("Web Share API not supported");
            }
        } catch (error) {
            console.error("Error sharing files:", error);
            showToast("Failed to share files: " + error.message, "error");

            // Fallback to BlueDrop's own sharing mechanism
            startSending();
        }
    }

    // Handle file saving with File System Access API
    async function saveFilesToDisk(fileBlob, fileName) {
        try {
            if ('showSaveFilePicker' in window) {
                // Use File System Access API
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'Files',
                        accept: {
                            'application/octet-stream': ['.bin', '.dat', '.file']
                        }
                    }]
                });

                // Create a writable stream
                const writable = await fileHandle.createWritable();

                // Write the blob to the file
                await writable.write(fileBlob);

                // Close the file
                await writable.close();

                showToast(`File "${fileName}" saved successfully`, "success");
                return true;
            } else {
                // Fallback to download attribute
                const url = URL.createObjectURL(fileBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`File "${fileName}" downloaded`, "success");
                return true;
            }
        } catch (error) {
            console.error("Error saving file:", error);
            showToast("Failed to save file: " + error.message, "error");
            return false;
        }
    }

    // Handle offline functionality
    function setupOfflineSupport() {
        window.addEventListener('online', () => {
            showToast("You are back online", "success");
        });

        window.addEventListener('offline', () => {
            showToast("You are offline. Some features may be limited.", "warning");
        });

        // Check initial state
        if (!navigator.onLine) {
            showToast("You are offline. Some features may be limited.", "warning");
        }
    }

    // Handle app installation
    let deferredPrompt;

    window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent the mini-infobar from appearing on mobile
        e.preventDefault();

        // Stash the event so it can be triggered later
        deferredPrompt = e;

        // Show install button or notification
        showInstallPrompt();
    });

    function showInstallPrompt() {
        if (!deferredPrompt) return;

        // Create install button
        const installButton = document.createElement('button');
        installButton.textContent = 'Install BlueDrop';
        installButton.classList.add('button');
        installButton.style.marginTop = '20px';
        installButton.addEventListener('click', async () => {
            // Show the install prompt
            deferredPrompt.prompt();

            // Wait for the user to respond to the prompt
            const {
                outcome
            } = await deferredPrompt.userChoice;

            // We no longer need the prompt
            deferredPrompt = null;

            // Remove the button
            installButton.remove();

            // Log the outcome
            console.log(`User ${outcome} the installation`);

            if (outcome === 'accepted') {
                showToast("Thanks for installing BlueDrop!", "success");
            }
        });

        // Add to main container
        mainContainer.appendChild(installButton);
    }

    // Initialize the application
    initApp();
    setupOfflineSupport();

    // GSAP Context for Spring Animations
    gsap.context(() => {
        // Button Animation
        gsap.utils.toArray(".button").forEach(button => {
            button.addEventListener("click", () => {
                if (navigator.vibrate) {
                    navigator.vibrate([50]); // Haptic Feedback on Click
                }

                gsap.to(button, {
                    duration: 0.5,
                    scale: 1.1,
                    yoyo: true,
                    repeat: 1,
                    ease: "elastic.out(1, 0.5)"
                });
            });
        });

        // Container Entrance Animation (on becoming active)
        const containers = [mainContainer, fileSelectContainer, receiveContainer, transferPopup, qrContainer,
            settingsContainer
        ];
        containers.forEach(container => {
            let config = {
                x: () => Math.random() > 0.5 ? 100 : -100,
                y: () => Math.random() > 0.5 ? 50 : -50,
                duration: 1.2,
                opacity: 0,
                ease: "elastic.out(1, 0.75)",
                stagger: 0.1
            }
            gsap.from(container, config);
        });
    });

    // Register Service Worker for PWA support
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').then(registration => {
                console.log('ServiceWorker registration successful');
            }).catch(error => {
                console.error('ServiceWorker registration failed:', error);
            });
        });
    }

    /**
     * -------UI Handlers-------
     */
    // --- UI Helper Functions ---
    function hideAllContainers() {
        mainContainer.classList.remove('active');
        fileSelectContainer.classList.remove('active');
        qrContainer.classList.remove('active');
        receiveContainer.classList.remove('active');
        transferPopup.classList.remove('active');
        settingsContainer.classList.remove('active');
        qrCodeContainer.classList.remove('active');
        connectionIdContainer.classList.remove('active');
        enterConnectionContainer.classList.remove('active');


    }

    function showMainContainer() {
        hideAllContainers();
        mainContainer.classList.add('active');
    }

    function openFileSelect() {
        hideAllContainers();
        fileSelectContainer.classList.add('active');
    }

    function showReceiveContainer() {
        hideAllContainers();
        receiveContainer.classList.add('active');
    }

    function showTransferPopup() {
        hideAllContainers();
        transferPopup.classList.add('active');
    }

    function showSettingsContainer() {
        hideAllContainers();
        settingsContainer.classList.add('active');
    }

    function hideFileSelectContainer() {
        fileSelectContainer.classList.remove('active');
    }

    function hideQRContainer() {
        qrContainer.classList.remove('active');
    }

    function hideReceiveContainer() {
        receiveContainer.classList.remove('active');
    }

    function hideTransferPopup() {
        transferPopup.classList.remove('active');
    }

    function hideSettingsContainer() {
        settingsContainer.classList.remove('active');
    }

    function showIncomingAlert() {
        incomingAlert.classList.add('active');
        setTimeout(() => {
            incomingAlert.classList.remove('active');
        }, 5000);
    }

    // --- File Selection and Handling ---

    function handleFileSelection(event) {
        selectedFiles = Array.from(event.target.files);
        renderFileList();
    }

    function renderFileList() {
        fileList.innerHTML = '';
        selectedFiles.forEach(file => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
    <span class="file-icon">${getFileIcon(file.name)}</span>
    <span>${file.name}</span>
    <span class="remove-file" data-name="${file.name}" style="cursor: pointer; color: red;">×</span>
    `;
            fileList.appendChild(listItem);
        });
    }


    // --- Transfer Logic ---

    async function startSending() {
        if (selectedFiles.length === 0) {
            showToast("Please select files to send.", "warning");
            return;
        }

        // Hide file select container
        hideFileSelectContainer();

        // Start the signaling process
        startSignaling(true);

        // Display the QR container
        openQRContainer();
    }

    async function startActualFileTransfer() {
        try {
            if (selectedFiles.length === 0) {
                showToast("No files selected to transfer.", "warning");
                return;
            }

            // Reset UI elements
            transferringList.innerHTML = '';
            progressBar.style.width = '0%';
            transferStatus.textContent = "Starting transfer...";
            transferSpeed.textContent = "0 KB/s";
            transferRemaining.textContent = "Calculating...";

            // Show transfer popup
            showTransferPopup();

            // Set the transfer flag to true
            transferOngoing = true;

            // Initialize tracking variables
            transferStartTime = Date.now();
            totalBytesTransferred = 0;
            totalBytes = selectedFiles.reduce((sum, file) => sum + file.size, 0);

            // Prepare the list of files to be transferred
            const fileList = selectedFiles.map(file => ({
                id: generateUUID(),
                name: file.name,
                size: file.size
            }));

            // Send metadata for all files first
            for (const file of selectedFiles) {
                //Convert file to ArrayBuffer
                const arrayBuffer = await fileToArrayBuffer(file);

                //Generate a file preview for images
                let preview = null;
                if (file.type.startsWith('image/')) {
                    preview = URL.createObjectURL(file);
                }

                const fileMeta = {
                    id: generateUUID(),
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    preview: preview
                };

                //Send the metadata to the receiver
                const metaMessage = JSON.stringify({
                    type: "file-meta",
                    meta: fileMeta
                });
                peer.send(metaMessage);
            }
            // Now, request acceptance from the receiver
            requestAnimationFrame(() => {
                const acceptMessage = JSON.stringify({
                    type: "transfer-accepted"
                });
                peer.send(acceptMessage);
            });
        } catch (error) {
            console.error("Error starting file transfer:", error);
            showToast("Failed to start file transfer: " + error.message, "error");
        }
    }


    async function sendFileChunks(file) {
        try {
            const fileId = generateUUID(); // Unique ID for this file
            const fileSize = file.size;
            let offset = 0;
            let chunkIndex = 0;
            const fileName = file.name;

            // Update UI for this file
            const listItem = document.createElement('li');
            listItem.innerHTML = `
    <span>${fileName}</span>
    <div class="file-progress">
        <div class="file-progress-bar" id="file-progress-${fileId}"></div>
    </div>
    <span id="file-progress-text-${fileId}">0%</span>
    `;
            transferringList.appendChild(listItem);

            // Read file in chunks
            while (offset < fileSize) {
                const chunk = file.slice(offset, offset + currentChunkSize);
                const arrayBuffer = await new Response(chunk).arrayBuffer();

                // Compress data
                const compressedData = compressData(arrayBuffer);

                // Encrypt data
                const {
                    data: encryptedData,
                    key
                } = await encryptData(compressedData, encryptionKey);

                // Send chunk
                peer.send(encryptedData);

                // Update offset and chunk index
                offset += currentChunkSize;
                chunkIndex++;

                // Calculate progress
                const progress = Math.min(100, Math.round((offset / fileSize) * 100));

                // Update UI for this file
                requestAnimationFrame(() => {
                    const progressBar = document.getElementById(`file-progress-${fileId}`);
                    if (progressBar) {
                        progressBar.style.width = progress + "%";
                    }

                    const progressText = document.getElementById(`file-progress-text-${fileId}`);
                    if (progressText) {
                        progressText.textContent = progress + "%";
                    }

                });
            }

            // File transfer completed successfully
            showToast(`File "${fileName}" transferred successfully`, "success");
            transferStatus.textContent = `Transfer complete: ${fileName}`;

            // Send transfer complete message
            peer.send(JSON.stringify({
                type: "transfer-complete"
            }));

            // Reset UI elements
            transferOngoing = false;
            clearAllIntervals();
            hideTransferPopup();
            showMainContainer();

        } catch (error) {
            console.error("Error in sendFileChunks:", error);
            showToast("Error transferring file: " + error.message, "error");

            // Notify the other party about the error
            peer.send(JSON.stringify({
                type: "error",
                message: "Failed to transfer file: " + error.message
            }));
        }
    }

    function updateFileProgress(fileId, progress) {
        // Get the DOM element
        const fileProgressBar = document.getElementById(`file-progress-${fileId}`);
        const fileProgressText = document.getElementById(`file-progress-text-${fileId}`);

        // Ensure the element exists
        if (!fileProgressBar || !fileProgressText) {
            console.error(`File progress bar with id ${fileId} not found`);
            return;
        }

        // Update progress bar and text
        requestAnimationFrame(() => {
            fileProgressBar.style.width = `${progress}%`;
            fileProgressText.textContent = `${progress}%`;
        });
    }

    function updateTransferStatus() {
        // Calculate elapsed time
        const elapsedTime = (Date.now() - transferStartTime) / 1000;

        // Calculate transfer speed
        const speed = totalBytesTransferred / elapsedTime;
        transferSpeed.textContent = `${formatBytes(speed)}/s`;

        // Calculate remaining time
        const remainingBytes = totalBytes - totalBytesTransferred;
        const remainingTime = remainingBytes / speed;

        transferRemaining.textContent = remainingTime > 0 && isFinite(remainingTime) ?
            `${Math.ceil(remainingTime)} seconds left` :
            "Calculating...";
    }

    function cancelTransfer() {
        if (!transferOngoing) {
            showToast("No transfer is currently in progress.", "warning");
            return;
        }

        if (!confirm("Are you sure you want to cancel the transfer?")) {
            return;
        }

        // Send cancellation message to the other peer
        peer.send(JSON.stringify({
            type: "transfer-cancelled"
        }));

        transferOngoing = false;
        clearAllIntervals();

        // Reset UI elements
        progressBar.style.width = '0%';
        transferStatus.textContent = "Transfer cancelled";
        transferSpeed.textContent = "0 KB/s";
        transferRemaining.textContent = "Calculating...";
        transferringList.innerHTML = "";

        // Hide transfer popup and show main container
        hideTransferPopup();
        showMainContainer();
    }

    function acceptTransfer() {
        // Send acceptance message to the other peer
        peer.send(JSON.stringify({
            type: "transfer-accepted"
        }));

        // Reset UI elements
        transferringList.innerHTML = '';
        progressBar.style.width = '0%';
        transferStatus.textContent = "Receiving files...";

        // Clear any existing data
        receivedFileData = [];
        totalBytesTransferred = 0;

        // Show transfer popup and hide receive container
        showTransferPopup();
        hideReceiveContainer();
    }


    async function declineTransfer() {
        try {
            // Send decline message to the other peer
            peer.send(JSON.stringify({
                type: "transfer-declined"
            }));

            // Reset UI elements
            incomingFileNameDisplay.textContent = "";
            incomingFileSizeDisplay.textContent = "";

            // Return to the main container
            hideReceiveContainer();
            showMainContainer();
        } catch (error) {
            console.error("Error declining transfer:", error);
            showToast("Failed to decline transfer: " + error.message, "error");
        }
    }


    async function processReceivedFile() {
        try {
            // Merge all data chunks
            let receivedData = receivedFileData;
            if (receivedData.length === 0) {
                throw new Error("No data received");
            }
            let finalData;
            if (receivedData[0] instanceof Uint8Array) {
                // If data is Uint8Array, concatenate
                let totalLength = 0;
                for (const chunk of receivedData) {
                    totalLength += chunk.length;
                }

                finalData = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of receivedData) {
                    finalData.set(chunk, offset);
                    offset += chunk.length;
                }
                finalData = finalData.buffer; // Convert to ArrayBuffer
            } else {
                // If data is string, concatenate
                finalData = receivedData.join('');
            }
            // Decompress data
            const decompressedData = decompressData(finalData);

            // Decrypt data
            const decryptedData = useEncryption ? await decryptData(finalData, encryptionKey) : decompressedData;
            if (typeof decryptedData === 'undefined') {
                throw new Error("Decryption failed");
            }
            let fileData;
            // If decryptedData is still a string, convert to ArrayBuffer
            if (typeof decryptedData === 'string') {
                const encoder = new TextEncoder();
                const uint8Array = encoder.encode(decryptedData);
                fileData = uint8Array.buffer; // Get ArrayBuffer
            } else {
                fileData = decryptedData;
            }
            // Convert ArrayBuffer to Blob
            const fileBlob = new Blob([fileData], {
                type: incomingFileMeta.type
            });

            // Save to disk
            await saveFilesToDisk(fileBlob, incomingFileMeta.name);

            // Store the file in IndexedDB
            await storeFileInIndexedDB({
                name: incomingFileMeta.name,
                type: incomingFileMeta.type,
                size: incomingFileMeta.size
            }, fileData);

            // Reset UI elements
            showToast(`File "${incomingFileMeta.name}" received and saved successfully`, "success");
            transferOngoing = false;

            // Send transfer complete message to sender
            peer.send(JSON.stringify({
                type: "transfer-complete"
            }));

            hideTransferPopup();
            showMainContainer();
        } catch (error) {
            console.error("Error processing received file:", error);
            showToast("Failed to process received file: " + error.message, "error");
        }
    }
</script>
</body>
</html>
