<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale: 1.0, viewport-fit: cover">
    <title>BlueDrop - Effortless File Transfers</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Exo+2:wght@400;700&family=Russo+One&family=Bebas+Neue&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
        integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewSTCcpyAfQKwiOp/oyuP3m18RReF9SvNKjC4JEjz+iCz2P+pIiuw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- WebRTC Libraries - Simple Peer -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js"
        integrity="sha512-IzJ2KzGgqR19V00jQ2R4w9G010Y2y4FjS7jJ+QO1w7w9J4+t2w9X70l+eXvL9G2C5K/5c7Vn3j839tQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>


    <style>
        /* iOS 18.2 / iPhone 16 Pro Max Futuristic Fonts */
        @font-face {
            font-family: 'SF Pro Display';
            src: url('https://fonts.cdnfonts.com/s/93781/SF-Pro-Display-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        /* Font Stack */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'SF Pro Display', 'Orbitron', 'Exo 2', 'Russo One', 'Bebas Neue', -apple-system,
                BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0d1117, #1e2a47);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            padding: clamp(10px, 2vw, 20px);
            overscroll-behavior: none;
        }

        /* Base Container Styles */
        .container,
        .file-select-container,
        .receive-container,
        .transfer-popup {
            text-align: center;
            padding: clamp(20px, 4vw, 40px);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: clamp(300px, 40vw, 500px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            margin-bottom: clamp(20px, 4vw, 40px);
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease-in-out;
            will-change: transform, opacity;
            transform: translate3d(0, 0, 0);
        }

        .container:not(.active),
        .file-select-container:not(.active),
        .receive-container:not(.active),
        .transfer-popup:not(.active) {
            display: none;
            opacity: 0;
            transform: translateY(20px);
        }

        .container.active,
        .file-select-container.active,
        .receive-container.active,
        .transfer-popup.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* Typography */
        h1 {
            font-size: clamp(32px, 5vw, 50px);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.5px;
            margin-bottom: 8px;
        }

        h2 {
            font-size: clamp(18px, 2vw, 24px);
            font-family: 'Exo 2', sans-serif;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: -0.3px;
            margin-bottom: 12px;
        }

        h3 {
            color: #ffffff;
        }

        p {
            font-size: clamp(16px, 2vw, 22px);
            font-family: 'Russo One', sans-serif;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: clamp(15px, 3vw, 25px);
            line-height: 1.5;
        }

        /* Buttons */
        .button {
            display: block;
            width: 100%;
            padding: clamp(12px, 2.5vw, 18px);
            margin: 10px 0;
            border-radius: 14px;
            font-size: clamp(18px, 2vw, 24px);
            font-family: 'Bebas Neue', sans-serif;
            font-weight: 700;
            cursor: pointer;
            border: none;
            color: white;
            background: linear-gradient(145deg, #3a69d4, #1f4bd6);
            box-shadow: inset 0 2px 5px rgba(255, 255, 255, 0.2), 0 4px 10px rgba(0, 0, 0, 0.3),
                inset 0px 0px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform, box-shadow;
            transform: translate3d(0, 0, 0);
        }

        .button:hover {
            background: linear-gradient(145deg, #4471e5, #1c47c1);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5), inset 0px 0px 10px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        .button:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .button-receive {
            background: linear-gradient(145deg, #7c6bff, #5a4ef9);
        }

        .button-receive:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
        }

        /* File Selection Container Styles */
        .file-select-container {
            overflow: hidden;
            /* Ensure no content overflows */
        }

        .file-select-container h3 {
            font-size: clamp(24px, 3vw, 30px);
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 15px;
        }

        .file-select-container input[type="file"] {
            display: none;
        }

        .file-select-container label {
            background: linear-gradient(145deg, #7c6bff, #5a4ef9);
            padding: clamp(10px, 2vw, 14px);
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            display: inline-block;
            margin-bottom: 20px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
            will-change: background;
            transform: translate3d(0, 0, 0);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            /* Spring-like transition */
        }

        .file-select-container label:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
            transform: scale(1.05);
            /* Slight scale increase on hover */
        }

        .file-list {
            text-align: left;
            margin-bottom: 20px;
            overflow-y: auto;
            /* Make file list scrollable if it overflows */
            max-height: 200px;
            /* Set a maximum height for the file list */
            padding-right: 10px;
            /* Add padding to prevent scrollbar from overlapping */
        }

        .file-list li {
            font-size: clamp(14px, 1.6vw, 18px);
            font-family: 'Russo One', sans-serif;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            will-change: color, transform;
            transform: translate3d(0, 0, 0);
            padding: 8px;
            border-radius: 8px;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), background-color 0.3s ease;
            /* Add transition */
        }

        .file-list li:hover {
            background-color: rgba(255, 255, 255, 0.05);
            /* Add a subtle background color on hover */
            transform: translateY(-2px);
            /* Lift the item slightly on hover */
        }


        .file-list li .file-icon {
            margin-right: 5px;
        }

        .file-list li .remove-file {
            cursor: pointer;
            color: #dc143c;
            transition: color 0.3s ease;
            /* Add transition for remove file icon */
        }

        .file-list li .remove-file:hover {
            color: #ff4d6a;
        }

        .file-select-container button {
            background: linear-gradient(145deg, #3a69d4, #1f4bd6);
            padding: clamp(10px, 2vw, 14px);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            /* Spring-like transition */
        }

        .file-select-container button:hover {
            background: linear-gradient(145deg, #4471e5, #1c47c1);
            transform: scale(1.03);
        }

        /* Receive Container Styles */
        .receive-container h3 {
            font-size: clamp(24px, 3vw, 30px);
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 15px;
        }

        .receive-container p {
            font-size: clamp(16px, 2vw, 22px);
            font-family: 'Russo One', sans-serif;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: clamp(15px, 3vw, 25px);
            line-height: 1.5;
        }

        .receive-container button {
            background: linear-gradient(145deg, #7c6bff, #5a4ef9);
            padding: clamp(10px, 2vw, 14px);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .receive-container button:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
        }

        /* File Transfer Popup Styles */
        .transfer-popup {
            overflow: hidden;
        }

        .transfer-popup h3 {
            font-size: clamp(24px, 3vw, 30px);
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 15px;
        }

        .progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #3a69d4, #7c6bff);
            border-radius: 5px;
            transition: width 0.2s ease-out;
            will-change: width;
            transform: translate3d(0, 0, 0);
        }

        .transfer-status {
            font-size: clamp(16px, 2vw, 20px);
            font-family: 'Russo One', sans-serif;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 15px;
        }

        #cancelBtn {
            background: linear-gradient(145deg, #7c6bff, #5a4ef9);
            padding: clamp(10px, 2vw, 14px);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(16px, 1.8vw, 20px);
            cursor: pointer;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            /* Spring-like transition */
        }

        #cancelBtn:hover {
            background: linear-gradient(145deg, #8671ff, #4a3ff9);
            transform: scale(1.03);
        }

        #transferringList {
            text-align: left;
            margin-bottom: 20px;
            overflow-y: auto;
            max-height: 150px;
            padding-right: 10px;
        }

        #transferringList li {
            font-size: clamp(14px, 1.6vw, 18px);
            font-family: 'Russo One', sans-serif;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            will-change: color, transform;
            transform: translate3d(0, 0, 0);
            padding: 8px;
            border-radius: 8px;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), background-color 0.3s ease;
        }

        #transferringList li:hover {
            background-color: rgba(255, 255, 255, 0.05);
            transform: translateY(-2px);
        }

        /* Incoming File Alert Styles */
        .incoming-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: clamp(10px, 2vw, 15px);
            border-radius: 8px;
            z-index: 1001;
            font-family: 'SF Pro Display', sans-serif;
            font-size: clamp(16px, 1.8vw, 18px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .incoming-alert.active {
            display: block;
            animation: slideDown 0.5s ease-out, fadeOut 3s forwards 3s;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }

        /* âœ… Fully Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container,
            .file-select-container,
            .receive-container,
            .transfer-popup {
                max-width: 95%;
            }

            h1 {
                font-size: 36px;
            }

            h2 {
                font-size: 20px;
            }

            p {
                font-size: 18px;
            }

            .button {
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 32px;
            }

            h2 {
                font-size: 18px;
            }

            p {
                font-size: 16px;
            }

            .button {
                font-size: 18px;
            }
        }
    </style>
</head>

<body>

    <div class="container active" id="mainContainer">
        <h1>BlueDrop</h1>
        <h2>Effortless File Transfers</h2>
        <p>Share files instantly with just a tap. Secure, fast, and designed for a seamless experience.</p>
        <button class="button" id="sendBtn" onclick="openFileSelect()">
            <i class="fas fa-upload"></i> Send Files
        </button>
        <button class="button button-receive" id="receiveBtn" onclick="openReceiveContainer()">
            <i class="fas fa-download"></i> Receive Files
        </button>
    </div>

    <!-- File Selection Container -->
    <div class="file-select-container" id="fileSelectContainer">
        <h3>Select Files to Send</h3>
        <input type="file" id="fileInput" multiple onchange="handleFileSelection(event)">
        <label for="fileInput">
            <i class="fas fa-plus-circle"></i> Choose Files
        </label>
        <ul class="file-list" id="fileList"></ul>
        <button onclick="startSending()">
            <i class="fas fa-paper-plane"></i> Send Selected Files
        </button>
    </div>

    <!-- Receive Container -->
    <div class="receive-container" id="receiveContainer">
        <h3>Incoming Transfer</h3>
        <p>Someone wants to share files with you.</p>

        <div
            style="background-color: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 10px; margin-bottom: 15px; display: flex; align-items: center; justify-content: flex-start;">
            <i class="fas fa-file fa-3x" style="margin-right: 10px; color: #fff;"></i>
            <div style="flex: 1; text-align: left;">
                <div style="font-size: 18px; color: #fff;" id="incomingFileName"></div>
                <div style="font-size: 14px; color: #eee;" id="incomingFileSize"></div>
            </div>
        </div>

        <div style="display: flex; justify-content: space-around;">
            <button
                style="background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px;"
                onclick="acceptTransfer()">Accept</button>
            <button
                style="background-color: rgb(255, 0, 0) !important; color: rgb(255, 255, 255) !important; border: none !important; padding: 10px 20px !important; border-radius: 8px !important; cursor: pointer !important; font-size: 16px !important;"
                onclick="declineTransfer()">Decline</button>
        </div>
    </div>

    <!-- File Transfer Popup -->
    <div class="transfer-popup" id="transferPopup">
        <h3>Transferring Files...</h3>
        <ul id="transferringList"></ul>
        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <p class="transfer-status" id="transferStatus"></p>
        <button id="cancelBtn" onclick="cancelTransfer()">Cancel</button>
    </div>

    <!-- Incoming File Alert -->
    <div class="incoming-alert" id="incomingAlert">
        Incoming File Transfer!
    </div>

    <!-- GSAP Animation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.1/gsap.min.js"></script>

    <script>
        const mainContainer = document.getElementById("mainContainer");
        const sendBtn = document.getElementById("sendBtn");
        const receiveBtn = document.getElementById("receiveBtn");
        const fileSelectContainer = document.getElementById("fileSelectContainer");
        const receiveContainer = document.getElementById("receiveContainer");
        const transferPopup = document.getElementById("transferPopup");
        const progressBar = document.getElementById("progressBar");
        const transferStatus = document.getElementById("transferStatus");
        const cancelBtn = document.getElementById("cancelBtn");
        const incomingAlert = document.getElementById("incomingAlert");
        const fileInput = document.getElementById("fileInput");
        const fileList = document.getElementById("fileList");
        const transferringList = document.getElementById("transferringList");
        const incomingFileNameDisplay = document.getElementById("incomingFileName");
        const incomingFileSizeDisplay = document.getElementById("incomingFileSize");

        let selectedFiles = [];
        let intervals = [];
        let transferOngoing = false;

        // WebRTC variables
        let peer;
        let initiator = false;
        let receivedFileData = [];
        let incomingFileMeta = null;


        // IndexedDB setup
        let db;
        const dbName = "BlueDropDB";
        const objectStoreName = "files";

        const request = indexedDB.open(dbName, 1);

        request.onerror = function (event) {
            console.error("Database error: " + event.target.errorCode);
        };

        request.onupgradeneeded = function (event) {
            db = event.target.result;
            const objectStore = db.createObjectStore(objectStoreName, { keyPath: "name" });
            objectStore.createIndex("category", "category", { unique: false }); // Example index
        };

        request.onsuccess = function (event) {
            db = event.target.result;
        };

        // Function to store file in IndexedDB
        function storeFileInIndexedDB(file, category = 'Uncategorized') {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([objectStoreName], "readwrite");
                const objectStore = transaction.objectStore(objectStoreName);

                const fileData = {
                    name: file.name,
                    data: file, // Consider storing only metadata if file is too large
                    category: category,
                    timestamp: Date.now()
                };

                const request = objectStore.add(fileData);

                request.onsuccess = () => {
                    resolve();
                };

                request.onerror = () => {
                    reject(new Error("Failed to store file in IndexedDB"));
                };
            });
        }

        // Function to retrieve file from IndexedDB
        function retrieveFileFromIndexedDB(fileName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([objectStoreName], "readonly");
                const objectStore = transaction.objectStore(objectStoreName);
                const request = objectStore.get(fileName);

                request.onsuccess = () => {
                    if (request.result) {
                        resolve(request.result.data);
                    } else {
                        reject(new Error("File not found in IndexedDB"));
                    }
                };

                request.onerror = () => {
                    reject(new Error("Failed to retrieve file from IndexedDB"));
                };
            });
        }

        function clearIntervalAllIntervals() {
            intervals.forEach(interval => clearInterval(interval));
            intervals = [];
        }

        // Function to simulate file transfer and update progress
        function simulateFileTransfer() {
            if (transferOngoing) return; // Prevent multiple transfers at once

            let currentFileIndex = 0;
            transferOngoing = true;

            // Create list items for each file
            transferringList.innerHTML = ''; // Clear previous list
            selectedFiles.forEach(file => {
                const listItem = document.createElement("li");
                listItem.textContent = `Transferring: ${file.name} - 0%`;
                listItem.id = `transferItem-${file.name.replace(/\W/g, '')}`;  // Create safe ID
                transferringList.appendChild(listItem);

                // Spring Animation for Transfer List Items
                gsap.fromTo(listItem, {
                    opacity: 0,
                    y: -20,
                    scale: 0.9
                }, {
                    opacity: 1,
                    y: 0,
                    scale: 1,
                    duration: 0.6,
                    ease: "elastic.out(1, 0.75)"
                });
            });

            function transferNextFile() {
                if (currentFileIndex >= selectedFiles.length) {
                    transferStatus.textContent = "Transfer Complete!";
                    transferOngoing = false;
                    setTimeout(() => {
                        closeTransferPopup();
                        closeFileSelect();
                        showMainContainer();
                    }, 1500);
                    return;
                }

                const file = selectedFiles[currentFileIndex];
                let progress = 0;
                const interval = setInterval(() => {
                    intervals.push(interval);
                    progress += 5; // Simulate progress
                    progressBar.style.width = progress + "%";
                    const listItem = document.getElementById(`transferItem-${file.name.replace(/\W/g, '')}`);
                    if (listItem) {
                        listItem.textContent = `Transferring: ${file.name} - ${progress}%`;
                    }

                    if (progress >= 100) {
                        clearInterval(interval);
                        intervals = intervals.filter(i => i !== interval); // remove cleared interval
                        currentFileIndex++;
                        if (listItem) {
                            listItem.textContent = `Transferred: ${file.name}`; // Show completed status
                        }

                        // Store the file in IndexedDB
                        storeFileInIndexedDB(file)
                            .then(() => {
                                console.log(`File "${file.name}" stored in IndexedDB`);
                            })
                            .catch(error => {
                                console.error("Error storing file:", error);
                            });

                        transferNextFile(); // Start the next file
                    }
                }, 100);
            }

            transferNextFile();
        }

        function cancelTransfer() {
            transferOngoing = false; // Set flag to stop the transfer
            clearIntervalAllIntervals();
            closeTransferPopup();
            closeFileSelect();
            showMainContainer();
        }

        // Open Transfer Popup Function
        function openTransferPopup() {
            hideMainContainer();
            hideFileSelect();
            hideReceiveContainer();
            transferringList.innerHTML = ""; // Clear previous transfer list
            progressBar.style.width = "0%";
            transferStatus.textContent = ""; // Clear any previous message
            transferPopup.classList.add("active");
        }

        // Close Transfer Popup Function
        function closeTransferPopup() {
            transferPopup.classList.remove("active");
        }

        // Incoming File Alert Function
        function showIncomingAlert() {
            incomingAlert.classList.add("active");
            setTimeout(() => {
                incomingAlert.classList.remove("active");
            }, 6000);
        }

        // Open File Select Container Function
        function openFileSelect() {
            hideMainContainer();
            hideReceiveContainer();
            hideTransferPopup();
            fileSelectContainer.classList.add("active");
        }

        // Close File Select Container Function
        function closeFileSelect() {
            fileSelectContainer.classList.remove("active");
            selectedFiles = [];
            fileList.innerHTML = "";
        }

        // Open Receive Container Function
        function openReceiveContainer() {
            hideMainContainer();
            hideFileSelect();
            hideTransferPopup();
            receiveContainer.classList.add("active");

            // Simulate receiving a file (replace with actual WebRTC logic)
            incomingFileMeta = {
                name: "document.pdf",
                size: "2.4 MB",
                type: "application/pdf"
            };

            // Update UI with incoming file metadata
            incomingFileNameDisplay.textContent = incomingFileMeta.name;
            incomingFileSizeDisplay.textContent = incomingFileMeta.size;

            showIncomingAlert();
        }

        // Close Receive Container Function
        function closeReceiveContainer() {
            receiveContainer.classList.remove("active");
        }

        // Function to Decline Transfer
        function declineTransfer() {
            closeReceiveContainer();
            showMainContainer();
            incomingFileMeta = null;
        }

        function showMainContainer() {
            mainContainer.classList.add("active");
        }

        function hideMainContainer() {
            mainContainer.classList.remove("active");
        }

        function hideFileSelect() {
            fileSelectContainer.classList.remove("active");
        }

        function hideReceiveContainer() {
            receiveContainer.classList.remove("active");
        }

        function hideTransferPopup() {
            transferPopup.classList.remove("active");
        }

        // Handle File Selection
        function handleFileSelection(event) {
            selectedFiles = Array.from(event.target.files);
            renderFileList();
        }

        // Render File List Function
        function renderFileList() {
            fileList.innerHTML = "";
            selectedFiles.forEach(file => {
                const listItem = document.createElement("li");
                listItem.innerHTML = `<i class="fas fa-file file-icon"></i>${file.name} <span class="remove-file" data-name="${file.name}">X</span>`;
                fileList.appendChild(listItem);

                // Spring Animation for File List Items
                gsap.fromTo(listItem, {
                    opacity: 0,
                    y: -20,
                    scale: 0.9
                }, {
                    opacity: 1,
                    y: 0,
                    scale: 1,
                    duration: 0.6,
                    ease: "elastic.out(1, 0.75)"
                });
            });
        }

        // Remove File from Selection
        fileList.addEventListener("click", (event) => {
            if (event.target.classList.contains("remove-file")) {
                const fileName = event.target.dataset.name;
                selectedFiles = selectedFiles.filter(file => file.name !== fileName);
                renderFileList(); // Re-render file list
            }
        });

        // Start Sending Files
        function startSending() {
            if (selectedFiles.length > 0) {
                // Check for WebAuthn availability
                if (window.PublicKeyCredential) {
                    // Attempt to register or authenticate
                    registerOrAuthenticate()
                        .then(() => {
                            // Proceed with file sending
                            openTransferPopup();
                            simulateFileTransfer();
                            closeFileSelect();
                        })
                        .catch((error) => {
                            console.error("Biometric authentication failed:", error);
                            alert("Biometric authentication failed. Please try again.");
                        });
                } else {
                    console.warn("WebAuthn not supported in this browser.");
                    // Fallback mechanism
                    openTransferPopup();
                    simulateFileTransfer();
                    closeFileSelect();
                }
            } else {
                alert("Please select files to send.");
            }
        }

        // Accept Transfer Function
        function acceptTransfer() {
            if (!incomingFileMeta) {
                alert("No incoming file to accept.");
                return;
            }

            closeReceiveContainer();
            openTransferPopup();
            simulateFileTransfer(); // Assuming you adapt this for a single incoming file
        }

        // AI-powered file categorization (basic example)
        function categorizeFile(fileName) {
            const lowerCaseName = fileName.toLowerCase();
            if (lowerCaseName.endsWith(".pdf") || lowerCaseName.endsWith(".doc") || lowerCaseName.endsWith(".docx")) {
                return "Documents";
            } else if (lowerCaseName.endsWith(".mp4") || lowerCaseName.endsWith(".mov") || lowerCaseName.endsWith(".avi")) {
                return "Videos";
            } else if (lowerCaseName.endsWith(".jpg") || lowerCaseName.endsWith(".jpeg") || lowerCaseName.endsWith(".png")) {
                return "Images";
            } else {
                return "Uncategorized";
            }
        }

        // Speech API
        function startVoiceRecording() {
            return new Promise((resolve, reject) => {
                const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;

                recognition.onresult = (event) => {
                    const result = event.results[0][0].transcript;
                    resolve(result);
                };

                recognition.onerror = (event) => {
                    reject(new Error("Speech recognition error: " + event.error));
                };

                recognition.start();
            });
        }

        // WebAuthn Registration/Authentication (Simplified)
        async function registerOrAuthenticate() {
            // In a real implementation, this would handle both registration and authentication
            // For simplicity, we'll just simulate authentication success
            return new Promise((resolve, reject) => {
                // Simulate a small delay to mimic real-world authentication
                setTimeout(() => {
                    // Always resolve as "authenticated" for this demo
                    resolve({ authenticated: true });
                }, 500);
            });
        }


        // GSAP Context for Spring Animations
        gsap.context(() => {

            // Button Animation
            gsap.utils.toArray(".button").forEach(button => {
                button.addEventListener("click", () => {
                    navigator.vibrate([50]); // Haptic Feedback on Click

                    gsap.to(button, {
                        duration: 0.5,
                        scale: 1.1,
                        yoyo: true,
                        repeat: 1,
                        ease: "elastic.out(1, 0.5)"
                    });
                });
            });

            // Container Entrance Animation (on becoming active)
            const containers = [mainContainer, fileSelectContainer, receiveContainer, transferPopup];
            containers.forEach(container => {
                let config = {
                    x: () => Math.random() > 0.5 ? 100 : -100,
                    y: () => Math.random() > 0.5 ? 50 : -50,
                    duration: 1.2,
                    opacity: 0,
                    ease: "elastic.out(1, 0.75)",
                    stagger: 0.1
                }
                gsap.from(container, config);
            });

        });

        // ********** WebRTC Implementation **********

        // Helper Function to Convert File to ArrayBuffer
        function fileToArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsArrayBuffer(file);
            });
        }

        // Initialize WebRTC Peer
        function initializePeer() {
            initiator = true; // Assume sender initiates connection
            peer = new SimplePeer({ initiator: initiator, trickle: false });

            peer.on('signal', data => {
                // Normally exchange signals with other peer using a signaling server
                console.log('SIGNAL', JSON.stringify(data))
            })

            peer.on('connect', () => {
                console.log('CONNECT');
            });

            peer.on('data', data => {
                receivedFileData.push(data);
                console.log('RECV: ' + data);
            })

            peer.on('stream', stream => {
                // got remote video stream, now let's show it in a video tag
                console.log('got remote stream')
                // If it's needed to add remote streams
                // var video = document.querySelector('video')
                // video.srcObject = stream
                // video.onloadedmetadata = function () {
                // video.play()
                // }
            })

            peer.on('close', () => {
                console.log("Peer Connection Closed");
                peer.destroy();
            });
        }

        // Function to Start WebRTC File Transfer
        async function startWebRTCFileTransfer(files) {
            if (!peer) {
                initializePeer();
            }

            for (const file of files) {
                const arrayBuffer = await fileToArrayBuffer(file);
                const chunkSize = 16384; // 16KB
                for (let i = 0; i < arrayBuffer.byteLength; i += chunkSize) {
                    const chunk = arrayBuffer.slice(i, i + chunkSize);
                    peer.send(chunk);
                }
                peer.send("__END_OF_FILE__");
                console.log(`File ${file.name} sent.`);
            }
        }

    </script>
</body>

</html>
